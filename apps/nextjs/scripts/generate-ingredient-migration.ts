/**
 * Generate SQL migration file for seeding ingredients
 *
 * Run: pnpm tsx scripts/generate-ingredient-migration.ts
 *
 * Output: src/db/migrations/NNNN_insert_ingredients.sql
 */

import { parse } from 'csv-parse/sync'
import { readFileSync, writeFileSync, readdirSync } from 'fs'
import { resolve, dirname, join, relative } from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const BATCH_SIZE = 100

const INGREDIENT_CATEGORIES = [
  'non_classified',
  'e100_e199',
  'ferments',
  'dairy',
  'cheeses',
  'salt',
  'meat',
  'starch',
  'oils_and_fats',
  'alcohol',
  'aroma',
  'cereal',
  'cocoa',
  'water',
  'fruit',
  'vegetables',
  'beans',
  'nuts',
  'seed',
  'plants',
  'mushroom',
  'fish',
  'molluscs',
  'crustaceans',
  'bee_ingredients',
  'synthesized',
  'poultry',
  'eggs',
  'parts',
  'compound_ingredients',
] as const

function escapeSQL(str: string): string {
  return str.replace(/'/g, "''")
}

function main() {
  // Read CSV file
  const scriptDir = __dirname
  const appDir = dirname(scriptDir)
  const repoRoot = dirname(dirname(appDir))
  const csvPath = join(repoRoot, 'research', 'en-ingredient-names.csv')

  console.log(`Reading CSV from: ${csvPath}`)

  const csvContent = readFileSync(csvPath, 'utf-8')
  const records = parse(csvContent, {
    columns: true,
    skip_empty_lines: true,
    trim: true,
  }) as Array<{ name: string; category: string }>

  console.log(`Parsed ${records.length} ingredients from CSV`)

  // Validate categories
  const validCategories = new Set(INGREDIENT_CATEGORIES)
  const categoryBreakdown: Record<string, number> = {}

  for (const record of records) {
    if (!validCategories.has(record.category as any)) {
      throw new Error(
        `Invalid category '${record.category}' for ingredient '${record.name}'`
      )
    }
    categoryBreakdown[record.category] = (categoryBreakdown[record.category] || 0) + 1
  }

  // Generate SQL
  const lines: string[] = [
    '-- Seed ingredients from research/en-ingredient-names.csv',
    '-- Generated by: pnpm tsx scripts/generate-ingredient-migration.ts',
    `-- Count: ${records.length} ingredients`,
    '',
  ]

  // Process in batches for readable SQL
  for (let i = 0; i < records.length; i += BATCH_SIZE) {
    const batch = records.slice(i, i + BATCH_SIZE)
    const batchNum = Math.floor(i / BATCH_SIZE) + 1
    const totalBatches = Math.ceil(records.length / BATCH_SIZE)

    lines.push(`-- Batch ${batchNum}/${totalBatches}`)
    lines.push('INSERT INTO "ingredients" ("name", "category") VALUES')

    const values = batch.map((record, idx) => {
      const name = escapeSQL(record.name.toLowerCase().trim())
      const category = record.category
      const comma = idx < batch.length - 1 ? ',' : ''
      return `  ('${name}', '${category}')${comma}`
    })

    lines.push(...values)
    lines.push('ON CONFLICT ("name") DO NOTHING;')
    lines.push('')
  }

  // Determine next migration number
  const migrationsDir = join(appDir, 'src', 'db', 'migrations')
  const existingMigrations = readdirSync(migrationsDir)
    .filter((f) => f.match(/^\d{4}_.*\.sql$/))
    .map((f) => parseInt(f.split('_')[0]))
    .filter((n) => !isNaN(n))

  const nextNum = existingMigrations.length > 0 ? Math.max(...existingMigrations) + 1 : 1
  const migrationFile = join(
    migrationsDir,
    `${String(nextNum).padStart(4, '0')}_insert_ingredients.sql`
  )

  // Write migration file
  writeFileSync(migrationFile, lines.join('\n'))

  console.log(`\nGenerated migration: ${relative(process.cwd(), migrationFile)}`)
  console.log(`  Total batches: ${Math.ceil(records.length / BATCH_SIZE)}`)
  console.log(`  Batch size: ${BATCH_SIZE}`)
  console.log('\nCategory breakdown:')
  for (const [category, count] of Object.entries(categoryBreakdown).sort(
    (a, b) => b[1] - a[1]
  )) {
    console.log(`  ${category}: ${count}`)
  }
}

main()
